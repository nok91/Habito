{"version":3,"sources":["../src/helpers.js"],"names":["getVal","firebase","path","notSetValue","dotPath","valueAtPath","isLoaded","args","length","arg","isEmpty","fixPath","substring","buildChildList","state","list","p","val","key","getKey","populateByKey","dotRoot","root","split","join","pathArr","childParam","push","pathString","data","keyProp","populateChild","child","childVal","populateVal","childAlias","populate","populates","splitPath","indexOf","populatesForData","someArrayItemHasKey","array","item","dataHasPopulateChilds","map","dataValue","value","populatedValue","reduce","acc","v","childKey","populatesForDataItem","obj"],"mappings":"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","sourcesContent":["import {\n  size,\n  set,\n  get,\n  has,\n  last,\n  map,\n  mapValues,\n  every,\n  reduce,\n  defaultsDeep,\n  isString,\n  compact,\n  some,\n  isArray,\n  isFunction\n} from 'lodash'\nimport { topLevelPaths } from './constants'\nimport { getPopulateObjs } from './utils/populate'\nimport { getDotStrPath } from './utils/reducers'\n\n/**\n * @description Get a value from firebase using slash notation.  This enables an easy\n * migration from v1's dataToJS/pathToJS/populatedDataToJS functions to v2 syntax\n * **NOTE:** Setting a default value will cause `isLoaded` to always return true\n * @param {Object} firebase - Firebase instance (state.firebase)\n * @param {String} path - Path of parameter to load\n * @param {Any} notSetValue - Value to return if value is not\n * found in redux. This will cause `isLoaded` to always return true (since\n * value is set from the start).\n * @return {Any} Data located at path within firebase.\n * @example <caption>Basic</caption>\n * import { compose } from 'redux'\n * import { connect } from 'react-redux'\n * import { firebaseConnect, getVal } from 'react-redux-firebase'\n *\n * const enhance = compose(\n *   firebaseConnect(['todos/user1']),\n *   connect(({ firebase }) => ({\n *     // this.props.todos loaded from state.firebase.data.todos\n *     todos: getVal(firebase, 'data/todos/user1')\n *   })\n * )\n * export default enhance(SomeComponent)\n * @example <caption>Base Paths</caption>\n * import { connect } from 'react-redux'\n * import { firebaseConnect, getVal } from 'react-redux-firebase'\n * // easily replace pathToJS with getVal\n *\n * export default connect(({ firebase }) => ({\n *   // this.props.auth loaded from state.firebase.auth\n *   auth: getVal(firebase, 'auth'),\n *   profile: getVal(firebase, 'profile')\n * })(SomeComponent)\n * @example <caption>Default Value</caption>\n * import { compose } from 'redux'\n * import { connect } from 'react-redux'\n * import { firebaseConnect, getVal } from 'react-redux-firebase'\n *\n * const defaultValue = {\n *  1: {\n *    text: 'Example Todo'\n *  }\n * }\n *\n * const enhance = compose(\n *   firebaseConnect(['todos/user1']),\n *   connect(({ firebase }) => ({\n *     // this.props.todos loaded from state.firebase.data.todos\n *     todos: getVal(firebase, 'data/todos/user1', defaultValue)\n *   })\n * )\n *\n * export default enhance(SomeComponent)\n */\nexport function getVal(firebase, path, notSetValue) {\n  if (!firebase) {\n    return notSetValue\n  }\n\n  const dotPath = getDotStrPath(path)\n  const valueAtPath = get(firebase, dotPath, notSetValue)\n\n  return valueAtPath\n}\n\n/**\n * @description Detect whether items are loaded yet or not\n * @param {Object} item - Item to check loaded status of. A comma separated\n * list is also acceptable.\n * @return {Boolean} Whether or not item is loaded\n * @example\n * import React from 'react'\n * import PropTypes from 'prop-types'\n * import { compose } from 'redux'\n * import { connect } from 'react-redux'\n * import { firebaseConnect, isLoaded, isEmpty } from 'react-redux-firebase'\n *\n * const enhance = compose(\n *   firebaseConnect(['todos']),\n *   connect(({ firebase: { data: { todos } } }) => ({\n *     todos // state.firebase.data.todos from redux passed as todos prop\n *   }))\n * )\n *\n * const Todos = ({ todos }) => {\n *   // Message for if todos are loading\n *   if(!isLoaded(todos)) {\n *     return <span>Loading...</span>\n *   }\n *\n *   // Message if todos are empty\n *   if(isEmpty(todos)) {\n *     return <span>No Todos Found</span>\n *   }\n *\n *   return <div><pre>{JSON.stringify(todos, null, 2)}</pre></div>\n * }\n *\n * Todos.propTypes = {\n *   todos: PropTypes.object\n * }\n *\n * export default enhance(Todos)\n */\nexport function isLoaded(...args) {\n  return !args || !args.length\n    ? true\n    : every(args, arg => arg !== undefined && get(arg, 'isLoaded') !== false)\n}\n\n/**\n * @description Detect whether items are empty or not\n * @param {Object} item - Item to check loaded status of. A comma seperated list\n * is also acceptable.\n * @return {Boolean} Whether or not item is empty\n * @example\n * import React from 'react'\n * import PropTypes from 'prop-types'\n * import { compose } from 'redux'\n * import { connect } from 'react-redux'\n * import { firebaseConnect, isEmpty, isLoaded } from 'react-redux-firebase'\n *\n * const enhance = compose(\n *   firebaseConnect(['todos']),\n *   connect(({ firebase: { data: { todos } } }) => ({\n *     todos // state.firebase.data.todos from redux passed as todos prop\n *   }))\n * )\n *\n * const Todos = ({ todos }) => {\n *   // Message for if todos are loading\n *   if(!isLoaded(todos)) {\n *     return <span>Loading...</span>\n *   }\n *\n *   // Message if todos are empty\n *   if(isEmpty(todos)) {\n *     return <span>No Todos Found</span>\n *   }\n *\n *   return <todos>{JSON.stringify(todos)}</todos>\n * }\n *\n * Todos.propTypes = {\n *   todos: PropTypes.object\n * }\n *\n * export default enhance(Todos)\n */\nexport function isEmpty(...args) {\n  return some(args, arg => !(arg && size(arg)) || arg.isEmpty === true)\n}\n\n/**\n * @description Fix path by adding \"/\" to path if needed\n * @param {String} path - Path string to fix\n * @return {String} - Fixed path\n * @private\n */\nexport function fixPath(path) {\n  return (path.substring(0, 1) === '/' ? '' : '/') + path\n}\n\n/**\n * @private\n * @description Build child list based on populate config\n * @param {Object} data - Firebase state object\n * @param {Object} list - Path of parameter to load\n * @param {Object} populateSettings - Object with population settings\n */\nconst buildChildList = (state, list, p) =>\n  mapValues(list, (val, key) => {\n    let getKey = val\n    // Handle key: true lists\n    if (val === true || p.populateByKey) {\n      getKey = key\n    }\n    // Allow for aliasing populated data see #126 for more details\n    const dotRoot = compact(p.root.split('/')).join('.')\n    const pathArr = [dotRoot, getKey]\n\n    // Handle child param\n    if (p.childParam) {\n      pathArr.push(p.childParam)\n    }\n\n    const pathString = pathArr.join('.')\n\n    // Set to child under key if populate child exists\n    if (get(state.data, pathString)) {\n      return p.keyProp\n        ? { [p.keyProp]: getKey, ...get(state.data, pathString) }\n        : get(state.data, pathString)\n    }\n    // Populate child does not exist\n    return val === true || p.populateByKey ? val : getKey\n  })\n\n/**\n * @private\n * @description Populate a child based on config. Handles list population\n * by making use of buildChildList.\n * @param {Object} state - Firebase state object\n * @param {Object} child - Path of parameter to load\n * @param {Object} populateSettings - Object with population settings\n */\nfunction populateChild(state, child, p) {\n  // no matching child parameter\n  const childVal = get(child, p.child)\n  if (!child || !childVal) {\n    return null\n  }\n  // populate child is key\n  if (isString(childVal)) {\n    // attach child paramter if it exists\n    const dotRoot = compact(p.root.split('/')).join('.')\n    const pathArr = [dotRoot, childVal]\n\n    // Handle child param\n    if (p.childParam) {\n      pathArr.push(p.childParam)\n    }\n\n    const pathString = pathArr.join('.')\n\n    const populateVal = get(state.data, pathString)\n    if (populateVal) {\n      return set(\n        {},\n        p.childAlias || p.child,\n        p.keyProp ? { [p.keyProp]: childVal, ...populateVal } : populateVal\n      )\n    }\n    // matching child does not exist\n    return child\n  }\n  // populate child list\n  return set({}, p.childAlias || p.child, buildChildList(state, childVal, p))\n}\n\n/**\n * @description Populate with data from redux.\n * @param {Object} state - Firebase state object (state.firebase in redux store)\n * @param {String} path - Path of parameter to load\n * @param {Array} populates - Array of populate config objects\n * @param {Object|String|Boolean} notSetValue - Value to return if value is not found\n * @return {Object} Data located at path within Immutable Object\n * @example <caption>Basic</caption>\n * import { compose } from 'redux'\n * import { connect } from 'react-redux'\n * import { firebaseConnect } from 'react-redux-firebase'\n * const populates = [{ child: 'owner', root: 'users' }]\n *\n * const enhance = compose(\n *   firebaseConnect([\n *     { path: 'todos', populates } // load \"todos\" and matching \"users\" to redux\n *   ]),\n *   connect((state) => ({\n *     // this.props.todos loaded from state.firebase.data.todos\n *     // each todo has child 'owner' populated from matching uid in 'users' root\n *     // for loading un-populated todos use state.firebase.data.todos\n *     todos: populate(state.firebase, 'todos', populates),\n *   })\n * )\n *\n * export default enhance(SomeComponent)\n */\nexport function populate(state, path, populates, notSetValue) {\n  const splitPath = compact(path.split('/'))\n  // append 'data' prefix to path if it is not a top level path\n  const pathArr =\n    topLevelPaths.indexOf(splitPath[0]) === -1\n      ? ['data', ...splitPath]\n      : splitPath\n  const dotPath = pathArr.join('.')\n  // Gather data from top level if path is profile (handles populating profile)\n  const data = get(state, dotPath, notSetValue)\n\n  // Return notSetValue for undefined child\n  if (!state || data === notSetValue) {\n    return notSetValue\n  }\n  // Return null for null child\n  if (data === null) {\n    return null\n  }\n\n  // check for if data is single object or a list of objects\n  const populatesForData = getPopulateObjs(\n    isFunction(populates) ? populates(last(pathArr), data) : populates\n  )\n\n  if (isArray(data)) {\n    // When using a path in ordered, data will be an array instead of an object\n    // and data is located at the `value` prop\n    const someArrayItemHasKey = array => key =>\n      some(array, item => has(item, key))\n\n    // Check items within the list to see if value exists for some populate parameters\n    const dataHasPopulateChilds = some(populatesForData, populate =>\n      someArrayItemHasKey(data)(['value', populate.child])\n    )\n\n    // Populate if populate children exist\n    if (dataHasPopulateChilds) {\n      return data.map(({ key, value: dataValue }) => {\n        const populatedValue = populatesForData\n          .map(p => populateChild(state, dataValue, p))\n          .reduce((acc, v) => defaultsDeep(v, acc), dataValue)\n\n        return {\n          key,\n          value: populatedValue\n        }\n      })\n    }\n\n    // return unpopulated data if no populates have values\n    return data\n  }\n\n  // check each populate child parameter for existence\n  const dataHasPopulateChilds = some(populatesForData, p => has(data, p.child))\n\n  // Single object that contains at least one child parameter\n  if (dataHasPopulateChilds) {\n    return populatesForData\n      .map(p => populateChild(state, data, p))\n      .reduce((acc, v) => defaultsDeep(v, acc), data)\n  }\n\n  // Return for profile since it is a single object (following is for a list of objects)\n  // TODO: Improve this logic to allow for other paths containing profile\n  if (pathArr.indexOf('profile') !== -1) {\n    return data\n  }\n\n  // Data is a map of objects, each value has parameters to be populated\n  return mapValues(data, (child, childKey) => {\n    // use child's key if doing ordered populate\n    const key = pathArr[0] === 'ordered' ? child.key : childKey\n    // get populate settings on item level (passes child if populates is a function)\n    const populatesForDataItem = getPopulateObjs(\n      isFunction(populates) ? populates(key, child) : populates\n    )\n    // confirm at least one populate value exists on child\n    const dataHasPopulateChilds = some(populatesForDataItem, p =>\n      has(child, p.child)\n    )\n    // return unmodified child if no populate params exist on child\n    if (!dataHasPopulateChilds) {\n      return child\n    }\n    // combine data from all populates to one object starting with original data\n    return reduce(\n      map(populatesForDataItem, p => populateChild(state, child, p)),\n      (obj, v) => defaultsDeep(v, obj),\n      child\n    )\n  })\n}\n"],"file":"helpers.js"}