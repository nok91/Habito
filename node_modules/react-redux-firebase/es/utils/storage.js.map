{"version":3,"sources":["../../src/utils/storage.js"],"names":["FILE_UPLOAD_ERROR","actionTypes","FILE_UPLOAD_PROGRESS","deleteFile","firebase","path","dbPath","storage","ref","delete","then","database","firestore","metaDeletePromise","_","config","useFirestoreForStorageMeta","doc","remove","createUploadMetaResponseHandler","fileData","uploadTaskSnapshot","downloadURL","metaDataSnapshot","result","snapshot","key","id","File","uploadTaskSnaphot","createdAt","FieldValue","serverTimestamp","ServerValue","TIMESTAMP","getDownloadURLFromUploadTaskSnapshot","getDownloadURL","Promise","resolve","downloadURLs","writeMetadataToDb","options","fileMetadataFactory","metadataFactory","metaFactoryFunction","metadata","resultFromSnap","metaSetPromise","collection","add","newMetaRef","push","set","uploadFileWithProgress","dispatch","file","filename","meta","uploadEvent","put","unListen","on","TaskEvent","STATE_CHANGED","next","type","payload","percent","Math","floor","bytesTransferred","totalBytes","error","err","complete"],"mappings":"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","sourcesContent":["import { isFunction, omitBy, isUndefined } from 'lodash'\nimport { actionTypes } from '../constants'\n\nconst { FILE_UPLOAD_ERROR, FILE_UPLOAD_PROGRESS } = actionTypes\n\n/**\n * Delete file from Firebase Storage with support for deleteing meta\n * data from database (either Real Time Database or Firestore depending on\n * config)\n * @param {Object} firebase - Internal firebase object\n * @param  {String} path - Path to File which should be deleted\n * @param  {String} dbPath - Path of meta data with Database (Real Time Or\n * Firestore depnding on config)\n * @return {Promise} Resolves with path and dbPath\n */\nexport function deleteFile(firebase, { path, dbPath }) {\n  return firebase\n    .storage()\n    .ref(path)\n    .delete()\n    .then(() => {\n      // return path if dbPath or a database does not exist\n      if (!dbPath || (!firebase.database && !firebase.firestore)) {\n        return { path }\n      }\n\n      // Choose delete function based on config (Handling Firestore and RTDB)\n      const metaDeletePromise = () =>\n        firebase._.config.useFirestoreForStorageMeta\n          ? firebase\n              .firestore()\n              .doc(dbPath)\n              .delete() // file meta in Firestore\n          : firebase\n              .database()\n              .ref(dbPath)\n              .remove() // file meta in RTDB\n\n      return metaDeletePromise().then(() => ({ path, dbPath }))\n    })\n}\n\n/**\n * Create a function to handle response from upload.\n * @param  {Object} fileData - File data which was uploaded\n * @param  {Object} uploadTaskSnapshot - Snapshot from storage upload task\n * @return {Function} Function for handling upload result\n */\nfunction createUploadMetaResponseHandler({\n  fileData,\n  firebase,\n  uploadTaskSnapshot,\n  downloadURL\n}) {\n  /**\n   * Converts upload meta data snapshot into an object (handling both\n   * RTDB and Firestore)\n   * @param  {Object} metaDataSnapshot - Snapshot from metadata upload (from\n   * RTDB or Firestore)\n   * @return {Object} Upload result including snapshot, key, File\n   */\n  return function uploadResultFromSnap(metaDataSnapshot) {\n    const { useFirestoreForStorageMeta } = firebase._.config\n    const result = {\n      snapshot: metaDataSnapshot,\n      key: metaDataSnapshot.key || metaDataSnapshot.id,\n      File: fileData,\n      metaDataSnapshot,\n      uploadTaskSnapshot,\n      // Support legacy method\n      uploadTaskSnaphot: uploadTaskSnapshot,\n      createdAt: useFirestoreForStorageMeta\n        ? firebase.firestore.FieldValue.serverTimestamp()\n        : firebase.database.ServerValue.TIMESTAMP\n    }\n    // Attach id if it exists (Firestore)\n    if (metaDataSnapshot.id) {\n      result.id = metaDataSnapshot.id\n    }\n    // Attach downloadURL if it exists\n    if (downloadURL) {\n      result.downloadURL = downloadURL\n    }\n    return result\n  }\n}\n\nfunction getDownloadURLFromUploadTaskSnapshot(uploadTaskSnapshot) {\n  // Handle different downloadURL patterns (Firebase JS SDK v5.*.* vs v4.*.*)\n  if (\n    uploadTaskSnapshot.ref &&\n    typeof uploadTaskSnapshot.ref.getDownloadURL === 'function'\n  ) {\n    // Get downloadURL and attach to response\n    return uploadTaskSnapshot.ref.getDownloadURL()\n  }\n  // Only attach downloadURL if downloadURLs is defined (not defined in v5.*.*)\n  return Promise.resolve(\n    uploadTaskSnapshot.downloadURLs && uploadTaskSnapshot.downloadURLs[0]\n  )\n}\n\n/**\n * Write file metadata to Database (either Real Time Datbase or Firestore\n * depending on config).\n * @param {Object} firebase - Internal firebase object\n * @param  {Object} uploadTaskSnapshot - Snapshot from upload task\n * @param  {String} dbPath - Path of meta data with Database (Real Time Or\n * Firestore depnding on config)\n * @return {Promise} Resolves with payload (includes snapshot, File, and\n * metaDataSnapshot)\n */\nexport function writeMetadataToDb({\n  firebase,\n  uploadTaskSnapshot,\n  dbPath,\n  options\n}) {\n  // Support metadata factories from both global config and options\n  const { fileMetadataFactory, useFirestoreForStorageMeta } = firebase._.config\n  const { metadataFactory } = options\n  const metaFactoryFunction = metadataFactory || fileMetadataFactory\n  // Get download URL for use in metadata write\n  return getDownloadURLFromUploadTaskSnapshot(uploadTaskSnapshot).then(\n    downloadURL => {\n      // Apply fileMetadataFactory if it exists in config\n      const fileData = isFunction(metaFactoryFunction)\n        ? metaFactoryFunction(\n            uploadTaskSnapshot,\n            firebase,\n            uploadTaskSnapshot.metadata,\n            downloadURL\n          )\n        : omitBy(uploadTaskSnapshot.metadata, isUndefined)\n\n      // Create the snapshot handler function\n      const resultFromSnap = createUploadMetaResponseHandler({\n        fileData,\n        firebase,\n        uploadTaskSnapshot,\n        downloadURL\n      })\n\n      const metaSetPromise = fileData => {\n        if (useFirestoreForStorageMeta) {\n          return firebase // Write metadata to Firestore\n            .firestore()\n            .collection(dbPath)\n            .add(fileData)\n        }\n        // Create new reference for metadata\n        const newMetaRef = firebase\n          .database()\n          .ref(dbPath)\n          .push()\n        // Write metadata to Real Time Database and return new meta ref\n        return newMetaRef.set(fileData).then(res => newMetaRef)\n      }\n\n      return metaSetPromise(fileData).then(resultFromSnap)\n    }\n  )\n}\n\n/**\n * @description Upload a file with actions fired for progress, success, and errors\n * @param {Function} dispatch - Action dispatch function\n * @param {Object} firebase - Internal firebase object\n * @param {Object} opts - File data object\n * @param {Object} opts.path - Location within Firebase Stroage at which to upload file.\n * @param {Blob} opts.file - File to upload\n * @private\n */\nexport function uploadFileWithProgress(\n  dispatch,\n  firebase,\n  { path, file, filename, meta }\n) {\n  const uploadEvent = firebase\n    .storage()\n    .ref(`${path}/${filename}`)\n    .put(file)\n\n  const unListen = uploadEvent.on(firebase.storage.TaskEvent.STATE_CHANGED, {\n    next: snapshot => {\n      dispatch({\n        type: FILE_UPLOAD_PROGRESS,\n        meta,\n        payload: {\n          snapshot,\n          percent: Math.floor(\n            snapshot.bytesTransferred / snapshot.totalBytes * 100\n          )\n        }\n      })\n    },\n    error: err => {\n      dispatch({ type: FILE_UPLOAD_ERROR, meta, payload: err })\n      unListen()\n    },\n    complete: () => {\n      unListen()\n    }\n  })\n  return uploadEvent\n}\n"],"file":"storage.js"}