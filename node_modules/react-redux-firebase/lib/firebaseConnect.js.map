{"version":3,"sources":["../src/firebaseConnect.js"],"names":["RESERVED_PROPS","createFirebaseConnect","dataOrFn","WrappedComponent","FirebaseConnectWrapped","props","firebase","dispatch","inputAsFunc","prevData","ref","helpers","storage","database","auth","_firebaseEvents","np","data","store","itemsToSubscribe","itemsToUnsubscribe","Component","propTypes","PropTypes","func","isRequired","object","HoistedComp","FirebaseConnect","clashes","Object","keys","filter","k","includes","length","Error","join","_internalFirebase","displayName","wrappedComponent"],"mappings":"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","sourcesContent":["import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport { isEqual, differenceWith } from 'lodash'\nimport hoistStatics from 'hoist-non-react-statics'\nimport { watchEvents, unWatchEvents } from './actions/query'\nimport { getEventsFromInput, createCallable, wrapDisplayName } from './utils'\nimport ReactReduxFirebaseContext from './ReactReduxFirebaseContext'\n\n// Reserved props that should not be passed into a firebaseConnect wrapped\n// component. Will throw an error if they are.\nconst RESERVED_PROPS = ['firebase', 'dispatch']\n\n/**\n * @name createFirebaseConnect\n * @description Function that creates a Higher Order Component that\n * automatically listens/unListens to provided firebase paths using\n * React's Lifecycle hooks.\n * **WARNING!!** This is an advanced feature, and should only be used when\n * needing to access a firebase instance created under a different store key.\n * @param {String} [storeKey='store'] - Name of redux store which contains\n * Firebase state (state.firebase)\n * @return {Function} - HOC that accepts a watchArray and wraps a component\n * @example <caption>Basic</caption>\n * // this.props.firebase set on App component as firebase object with helpers\n * import { createFirebaseConnect } from 'react-redux-firebase'\n * // create firebase connect that uses another redux store\n * const firebaseConnect = createFirebaseConnect('anotherStore')\n * // use the firebaseConnect to wrap a component\n * export default firebaseConnect()(SomeComponent)\n */\nexport const createFirebaseConnect = (storeKey = 'store') => (\n  dataOrFn = []\n) => WrappedComponent => {\n  class FirebaseConnectWrapped extends Component {\n    static displayName = wrapDisplayName(\n      WrappedComponent,\n      'FirebaseConnectWrapped'\n    )\n    static wrappedComponent = WrappedComponent\n\n    firebaseEvents = []\n    firebase = null\n    prevData = null\n\n    componentDidMount() {\n      const { firebase, dispatch } = this.props\n\n      // Allow function to be passed\n      const inputAsFunc = createCallable(dataOrFn)\n      this.prevData = inputAsFunc(this.props, this.props)\n\n      const { ref, helpers, storage, database, auth } = firebase\n      this.firebase = { ref, storage, database, auth, ...helpers }\n\n      this._firebaseEvents = getEventsFromInput(this.prevData)\n\n      watchEvents(firebase, dispatch, this._firebaseEvents)\n    }\n\n    componentWillUnmount() {\n      const { firebase, dispatch } = this.props\n      unWatchEvents(firebase, dispatch, this._firebaseEvents)\n    }\n\n    componentWillReceiveProps(np) {\n      const { firebase, dispatch } = this.props\n      const inputAsFunc = createCallable(dataOrFn)\n      const data = inputAsFunc(np, this.store)\n\n      // Handle a data parameter having changed\n      if (!isEqual(data, this.prevData)) {\n        const itemsToSubscribe = differenceWith(data, this.prevData, isEqual)\n        const itemsToUnsubscribe = differenceWith(this.prevData, data, isEqual)\n\n        this.prevData = data\n        // UnWatch all current events\n        unWatchEvents(\n          firebase,\n          dispatch,\n          getEventsFromInput(itemsToUnsubscribe)\n        )\n        // Get watch events from new data\n        this._firebaseEvents = getEventsFromInput(data)\n\n        // Watch new events\n        watchEvents(firebase, dispatch, getEventsFromInput(itemsToSubscribe))\n      }\n    }\n\n    render() {\n      return <WrappedComponent {...this.props} />\n    }\n  }\n\n  FirebaseConnectWrapped.propTypes = {\n    dispatch: PropTypes.func.isRequired,\n    firebase: PropTypes.object.isRequired\n  }\n\n  const HoistedComp = hoistStatics(FirebaseConnectWrapped, WrappedComponent)\n\n  const FirebaseConnect = props => {\n    // Check that reserved props are not supplied to a FirebaseConnected\n    // component and if they are, throw an error so the developer can rectify\n    // this issue.\n    const clashes = Object.keys(props).filter(k => RESERVED_PROPS.includes(k))\n\n    if (clashes.length > 0) {\n      throw new Error(\n        `Supplied prop/s \"${clashes.join(\n          '\", \"'\n        )}\" are reserved for internal firebaseConnect() usage.`\n      )\n    }\n\n    return (\n      <ReactReduxFirebaseContext.Consumer>\n        {_internalFirebase => (\n          <HoistedComp\n            firebase={_internalFirebase}\n            dispatch={_internalFirebase.dispatch}\n            {...props}\n          />\n        )}\n      </ReactReduxFirebaseContext.Consumer>\n    )\n  }\n\n  FirebaseConnect.displayName = wrapDisplayName(\n    WrappedComponent,\n    'FirebaseConnect'\n  )\n\n  FirebaseConnect.wrappedComponent = WrappedComponent\n\n  return FirebaseConnect\n}\n\n/**\n/**\n * @name firebaseConnect\n * @extends React.Component\n * @description Higher Order Component that automatically listens/unListens\n * to provided firebase paths using React's Lifecycle hooks.\n * @param {Array} watchArray - Array of objects or strings for paths to sync\n * from Firebase. Can also be a function that returns the array. The function\n * is passed the current props and the firebase object.\n * @return {Function} - that accepts a component to wrap and returns the wrapped component\n * @example <caption>Basic</caption>\n * // props.firebase set on App component as firebase object with helpers\n * import { firebaseConnect } from 'react-redux-firebase'\n * export default firebaseConnect()(App)\n * @example <caption>Ordered Data</caption>\n * import { compose } from 'redux'\n * import { connect } from 'react-redux'\n * import { firebaseConnect } from 'react-redux-firebase'\n *\n * const enhance = compose(\n *   firebaseConnect([\n *     'todos' // sync /todos from firebase into redux\n *   ]),\n *   connect((state) => ({\n *     todos: state.firebase.ordered.todos\n *   })\n * )\n * \n * // use enhnace to pass todos list as props.todos\n * const Todos = enhance(({ todos })) =>\n *   <div>\n *     {JSON.stringify(todos, null, 2)}\n *   </div>\n * )\n * \n * export default enhance(Todos)\n * @example <caption>Data that depends on props</caption>\n * import { compose } from 'redux'\n * import { connect } from 'react-redux'\n * import { firebaseConnect, getVal } from 'react-redux-firebase'\n *\n * const enhance = compose(\n *   firebaseConnect((props) => ([\n *     `posts/${props.postId}` // sync /posts/postId from firebase into redux\n *   ]),\n *   connect((state, props) => ({\n *     post: getVal(state.firebase.data, `posts/${props.postId}`),\n *   })\n * )\n *\n * const Post = ({ post }) => (\n *   <div>\n *     {JSON.stringify(post, null, 2)}\n *   </div>\n * )\n *\n * export default enhance(Post)\n */\nexport default createFirebaseConnect()\n"],"file":"firebaseConnect.js"}