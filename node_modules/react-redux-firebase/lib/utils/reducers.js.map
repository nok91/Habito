{"version":3,"sources":["../../src/utils/reducers.js"],"names":["pathToArr","path","split","filter","p","getSlashStrPath","join","getDotStrPath","combineReducers","reducers","state","action","Object","keys","reduce","nextState","key","preserveValuesFromState","preserveSetting","Error","recursiveUnset","obj","isRecursiveCall","objectWithRemovedKey","newPath","match"],"mappings":"y6CAiBO,QAASA,CAAAA,SAAT,CAAmBC,IAAnB,CAAyB,CAC9B,MAAOA,CAAAA,IAAI,CAAGA,IAAI,CAACC,KAAL,CAAW,IAAX,EAAiBC,MAAjB,CAAwB,SAAAC,CAAC,QAAI,CAAC,CAACA,CAAN,CAAzB,CAAH,CAAuC,EACnD,CAQM,QAASC,CAAAA,eAAT,CAAyBJ,IAAzB,CAA+B,CACpC,MAAOD,CAAAA,SAAS,CAACC,IAAD,CAAT,CAAgBK,IAAhB,CAAqB,GAArB,CACR,CAQM,QAASC,CAAAA,aAAT,CAAuBN,IAAvB,CAA6B,CAClC,MAAOD,CAAAA,SAAS,CAACC,IAAD,CAAT,CAAgBK,IAAhB,CAAqB,GAArB,CACR,CAYM,QAASE,CAAAA,eAAT,CAAyBC,QAAzB,CAAmC,CACxC,MAAO,WAAwB,IAAvBC,CAAAA,KAAuB,wDAAf,EAAe,CAAXC,MAAW,wCAC7B,MAAOC,CAAAA,MAAM,CAACC,IAAP,CAAYJ,QAAZ,EAAsBK,MAAtB,CAA6B,SAACC,SAAD,CAAYC,GAAZ,CAAoB,CAMtD,MALAD,CAAAA,SAAS,CAACC,GAAD,CAAT,CAAiBP,QAAQ,CAACO,GAAD,CAAR,CAEfN,KAAK,CAACM,GAAD,CAFU,CAGfL,MAHe,CAKjB,CAAOI,SACR,CAPM,CAOJ,EAPI,CAQR,CACF,CAEM,QAASE,CAAAA,uBAAT,CAAiCP,KAAjC,CAAwCQ,eAAxC,CAAyDH,SAAzD,CAAoE,CAEzE,GAAI,yBAAWG,eAAX,CAAJ,CACE,MAAOA,CAAAA,eAAe,CAACR,KAAD,CAAQK,SAAR,CAAtB,CAGF,GAAI,wBAAUG,eAAV,GAA8BA,eAAlC,CACE,MAAOH,CAAAA,SAAS,kBAAQL,KAAR,CAAkBK,SAAlB,EAAgCL,KAAhD,CAGF,GAAI,sBAAQQ,eAAR,CAAJ,CACE,MAAO,mBAAKR,KAAL,CAAYQ,eAAZ,CAAP,CAGF,KAAM,IAAIC,CAAAA,KAAJ,CACJ,8DADI,CAGP,CAWM,QAASC,CAAAA,cAAT,CAAwBnB,IAAxB,CAA8BoB,GAA9B,CAA4D,IAAzBC,CAAAA,eAAyB,6DACjE,GAAI,CAACrB,IAAL,CACE,MAAOoB,CAAAA,GAAP,CAGF,GAA2B,CAAvB,oBAAK,kBAAIA,GAAJ,CAASpB,IAAT,CAAL,GAA4BqB,eAAhC,CACE,MAAOD,CAAAA,GAAP,CAN+D,GAU3DE,CAAAA,oBAAoB,CAAG,oBAAMtB,IAAN,CAAYoB,GAAZ,CAVoC,CAW3DG,OAAO,CAAGvB,IAAI,CAACwB,KAAL,CAAW,IAAX,EAAmB,sBAAQxB,IAAR,CAAc,UAAd,CAA0B,EAA1B,CAAnB,CAAmD,EAXF,CAYjE,MAAOmB,CAAAA,cAAc,CAACI,OAAD,CAAUD,oBAAV,IACtB","sourcesContent":["import {\n  get,\n  replace,\n  size,\n  isFunction,\n  isBoolean,\n  pick,\n  isArray\n} from 'lodash'\nimport { unset } from 'lodash/fp'\n\n/**\n * Create a path array from path string\n * @param  {String} path - Path seperated with slashes\n * @return {Array} Path as Array\n * @private\n */\nexport function pathToArr(path) {\n  return path ? path.split(/\\//).filter(p => !!p) : []\n}\n\n/**\n * Trim leading slash from path for use with state\n * @param  {String} path - Path seperated with slashes\n * @return {String} Path seperated with slashes\n * @private\n */\nexport function getSlashStrPath(path) {\n  return pathToArr(path).join('/')\n}\n\n/**\n * Convert path with slashes to dot seperated path (for use with lodash get/set)\n * @param  {String} path - Path seperated with slashes\n * @return {String} Path seperated with dots\n * @private\n */\nexport function getDotStrPath(path) {\n  return pathToArr(path).join('.')\n}\n\n/**\n * Combine reducers utility (abreveated version of redux's combineReducer).\n * Turns an object whose values are different reducer functions, into a single\n * reducer function.\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one.\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n * @private\n */\nexport function combineReducers(reducers) {\n  return (state = {}, action) => {\n    return Object.keys(reducers).reduce((nextState, key) => {\n      nextState[key] = reducers[key](\n        // eslint-disable-line no-param-reassign\n        state[key],\n        action\n      )\n      return nextState\n    }, {})\n  }\n}\n\nexport function preserveValuesFromState(state, preserveSetting, nextState) {\n  // Return result of function if preserve is a function\n  if (isFunction(preserveSetting)) {\n    return preserveSetting(state, nextState)\n  }\n  // Return original state if preserve is true\n  if (isBoolean(preserveSetting) && preserveSetting) {\n    return nextState ? { ...state, ...nextState } : state\n  }\n\n  if (isArray(preserveSetting)) {\n    return pick(state, preserveSetting) // pick returns a new object\n  }\n\n  throw new Error(\n    'Invalid preserve parameter. It must be an Object or an Array'\n  )\n}\n\n/**\n * Recursively unset a property starting at the deep path, and unsetting the parent\n * property if there are no other enumerable properties at that level.\n * @param  {String} path - Deep dot path of the property to unset\n * @param {Boolean} [isRecursiveCall=false] - Used internally to ensure that\n * the object size check is only performed after one iteration.\n * @return {Object} The object with the property deeply unset\n * @private\n */\nexport function recursiveUnset(path, obj, isRecursiveCall = false) {\n  if (!path) {\n    return obj\n  }\n\n  if (size(get(obj, path)) > 0 && isRecursiveCall) {\n    return obj\n  }\n  // The object does not have any other properties at this level.  Remove the\n  // property.\n  const objectWithRemovedKey = unset(path, obj)\n  const newPath = path.match(/\\./) ? replace(path, /\\.[^.]*$/, '') : ''\n  return recursiveUnset(newPath, objectWithRemovedKey, true)\n}\n"],"file":"reducers.js"}