{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: !0\n}), exports.uploadFile = uploadFile, exports.uploadFiles = uploadFiles, exports.deleteFile = deleteFile;\n\nvar _isFunction2 = _interopRequireDefault(require(\"lodash/isFunction\")),\n    _map2 = _interopRequireDefault(require(\"lodash/map\")),\n    _constants = require(\"../constants\"),\n    _actions = require(\"../utils/actions\"),\n    _storage = require(\"../utils/storage\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (null == source) return {};\n\n  var key,\n      i,\n      target = _objectWithoutPropertiesLoose(source, excluded);\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i], !(0 <= excluded.indexOf(key)) && Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (null == source) return {};\n  var key,\n      i,\n      target = {},\n      sourceKeys = Object.keys(source);\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i], 0 <= excluded.indexOf(key) || (target[key] = source[key]);\n  }\n\n  return target;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null == arguments[i] ? {} : arguments[i],\n        ownKeys = Object.keys(source);\n    \"function\" == typeof Object.getOwnPropertySymbols && (ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n    }))), ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  return key in obj ? Object.defineProperty(obj, key, {\n    value: value,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : obj[key] = value, obj;\n}\n\nvar FILE_UPLOAD_START = _constants.actionTypes.FILE_UPLOAD_START,\n    FILE_UPLOAD_ERROR = _constants.actionTypes.FILE_UPLOAD_ERROR,\n    FILE_UPLOAD_COMPLETE = _constants.actionTypes.FILE_UPLOAD_COMPLETE,\n    FILE_DELETE_START = _constants.actionTypes.FILE_DELETE_START,\n    FILE_DELETE_ERROR = _constants.actionTypes.FILE_DELETE_ERROR,\n    FILE_DELETE_COMPLETE = _constants.actionTypes.FILE_DELETE_COMPLETE;\n\nfunction uploadFile(dispatch, firebase, config) {\n  if (!firebase.storage) throw new Error(\"Firebase storage is required to upload files\");\n\n  var _ref = config || {},\n      path = _ref.path,\n      file = _ref.file,\n      dbPath = _ref.dbPath,\n      _ref$options = _ref.options,\n      options = void 0 === _ref$options ? {\n    progress: !1\n  } : _ref$options,\n      logErrors = firebase._.config.logErrors,\n      nameFromOptions = (0, _isFunction2.default)(options.name) ? options.name(file, firebase, config) : options.name,\n      filename = nameFromOptions || file.name,\n      meta = _objectSpread({}, config, {\n    filename: filename\n  });\n\n  dispatch({\n    type: FILE_UPLOAD_START,\n    payload: _objectSpread({}, config, {\n      filename: filename\n    })\n  });\n  return function uploadPromise() {\n    return options.progress ? (0, _storage.uploadFileWithProgress)(dispatch, firebase, {\n      path: path,\n      file: file,\n      filename: filename,\n      meta: meta\n    }) : firebase.storage().ref(\"\".concat(path, \"/\").concat(filename)).put(file);\n  }().then(function (uploadTaskSnapshot) {\n    return dbPath && (firebase.database || firebase.firestore) ? (0, _storage.writeMetadataToDb)({\n      firebase: firebase,\n      uploadTaskSnapshot: uploadTaskSnapshot,\n      dbPath: dbPath,\n      options: options\n    }).then(function (payload) {\n      return dispatch({\n        type: FILE_UPLOAD_COMPLETE,\n        meta: _objectSpread({}, config, {\n          filename: filename\n        }),\n        payload: payload\n      }), payload;\n    }) : (dispatch({\n      type: FILE_UPLOAD_COMPLETE,\n      meta: _objectSpread({}, config, {\n        filename: filename\n      }),\n      payload: {\n        uploadTaskSnapshot: uploadTaskSnapshot,\n        uploadTaskSnaphot: uploadTaskSnapshot\n      }\n    }), {\n      uploadTaskSnapshot: uploadTaskSnapshot,\n      uploadTaskSnaphot: uploadTaskSnapshot\n    });\n  }).catch(function (err) {\n    return logErrors && console.error && console.error(\"RRF: Error uploading file: \".concat(err.message || err), err), dispatch({\n      type: FILE_UPLOAD_ERROR,\n      path: path,\n      payload: err\n    }), Promise.reject(err);\n  });\n}\n\nfunction uploadFiles(dispatch, firebase, _ref2) {\n  var files = _ref2.files,\n      other = _objectWithoutProperties(_ref2, [\"files\"]);\n\n  return Promise.all((0, _map2.default)(files, function (file) {\n    return uploadFile(dispatch, firebase, _objectSpread({\n      file: file\n    }, other));\n  }));\n}\n\nfunction deleteFile(dispatch, firebase, _ref3) {\n  var path = _ref3.path,\n      dbPath = _ref3.dbPath;\n  return (0, _actions.wrapInDispatch)(dispatch, {\n    method: _storage.deleteFile,\n    args: [firebase, {\n      path: path,\n      dbPath: dbPath\n    }],\n    types: [FILE_DELETE_START, FILE_DELETE_COMPLETE, FILE_DELETE_ERROR]\n  });\n}","map":null,"metadata":{},"sourceType":"script"}